This README file gives a brief introduction about all three projects
for Assignment 6. Please read all sections VERY CAREFULLY ! Since
three projects are very closely related, it is important to understand
the big picture clearly before starting to work on your own.

Please post your questions, concerns, advertisements to the cs421 
mailing list (or the yale.cs.cs421 newsgroup). I expect we are going 
to have a very lively discussion.

WARNING: There are many typos and bugs in Appel's book. You may also
  notice that some of the files in the as6 directory are inconsistent 
  with those described in Appel's book. 

=============================================================================
1. The Top-Level Organization
=============================================================================

The current "/c/cs421/as/as6" directory contains the following:

 README.as6  --- this file

 FrontEnd --- a sample compiler front end (incl. lexer and parser, up to as4)
              (you should use your own front end in your final compiler)

 ItreeGen --- the type checker plus the ItreeGen related file
              (the env.sml and semant.sml files contain the sample solution
               from as5, but you should use your own as5 files)

 CodeGen  --- the CodeGen related files

 RegAlloc --- the RegAlloc related files

 main.sml --- the top-level glue to build the final compiler; ideally,
              you will be able to call Main.compile("foo.tig") to compile 
              the Tiger program "foo.tig" and generate the assembly code 
              in the "foo.tig.s" file. The assembly output will be 
              assembled and linked with the "runtime.c" file to generate 
              the final executable.

 reg-std.sig --- the standard register interface
               (see Section 7 of this README for more details)

 runtime.c --- the C library for the final Tiger compiler; the assembly
               code generated by your Tiger compiler will be linked with
               this runtime library to build the final executable.

 sources.cm --- a skeleton Makefile for the entire compiler.

Also, the "/c/cs421/as/Public" directory is a public buffer area; this is 
where you communicate with each other and submit your assignment.

=============================================================================
2. The ItreeGen Project
=============================================================================

The ItreeGen project is to implement the exercises described in the
end of Chapter 6 and 7 in Appel's book. 

The Frame module is to allocate locations for local variables, and 
to keep track of function nesting level and variable access information.
The Translate module is to translate the Toy abstract syntax (Absyn) 
into the Intermediate Tree language.

Please read Chapter 6 and 7 of Appel carefully before starting to work 
on these two modules.

In assignment 5, the "access" type and "level" type in the environment 
are declared as "unit" (see your "env.sml" file). In as6, you 
are going to modify your "env.sml" from 

   type access = unit   (* unused *)
   type level = unit    (* unused *)
   type label = unit    (* unused *)

to:
   type access = Translate.access
   type level = Translate.level
   type label = Temp.label

You need to augment the "env.sml" and "semant.sml" files to 
maintain the "access" and "level" information for all variables and 
functions. You also need to augment two new files "translate.sml" 
and "frame.sml". 

To avoid confusion, the following datatype (defined on Appel page 152)

   datatype exp = Ex of Tree.exp
                | Nx of Tree.stm
                | Cx of Tree.label * Tree.label -> Tree.stm

is now called "gexp". 

The low-level detail of translation from Absyn to the Intermediate Tree
language (the "gexp" type above, defined in Translate) should be all 
written in the "translate.sml" file. Modify the signature TRANSLATE and 
the structure Translate accordingly. The "semant.sml" will call these 
routines to make the actual translation happen.

The "as6/ItreeGen" directory contains the following files:
    (The env.sml and semant.sml files contain the sample solution
     from as5, but you should use your own as5 files)

 types.sml          --- the type definition
 temp.sml           --- defines the temporary variables and labels, etc.
 tree.sml           --- defines the intermediate trees 
 printtree.sml      --- functions to display itrees for debugging

 frame.sml          --- a skeleton frame.sml 

 env.sml            --- a skeleton env.sml (sample solution from as5)

 semant.sml         --- implement the type-checker and the translation
                        from absyn into itree frags; for *cleaner* interface, 
                        "semant.sml" achieves the "absyn->itree" translation 
                        by calling utility functions defined in the 
                        "translate.sml" file. HINT: "semant.sml" should never 
                        directly refer to anything defined in "frame.sml" or 
                        "tree.sml". 

 translate.sml      --- the bridge between "semant.sml" and 
                        "frame.sml,tree.sml"; it implements the low-level 
                        details for translation from absyn to itree (gexp).

 test.sml           --- (optional) an updated version of "as5/main.sml",
                        can be used for debugging. You need to change
                        the type of function "transprog" in the SEMANT 
                        signature to "Absyn.exp -> Translate.frag list" 
                        Just let "transprog" call "Translate.getResult()" 
                        before it returns.

You should work on semant.sml, env.sml, translate.sml, frame.sml, plus
detailed documentations.


=============================================================================
3. The CodeGen Project
=============================================================================

The CodeGen project is to implement the exercises described in the
end of Chapter 9 and 12 in Appel's book. 

Please read Chapter 8, 9, 12 of Appel carefully before starting to work 
on this project. Because we are generating code for x86 which only has
eight registers, you probably need to use some stack entries as pseudo 
registers (to support this, you need to reserve a few physical registers
to implement the memory to memory move). 

The "as6/CodeGen" directory contains the following files:

 canon.sml          --- (see Appel Chapter 8)
 assem.sml          --- (see Appel Chapter 9 and Page 201)

 Help-x86           --- some hints on the X86 assembly code (read this first)
 Help-PPC           --- some hints on the PowerPC assembly code

 register.sml       --- all machine-dependent register details should
                        be defined here. In Appel's book, this is supposed
                        to be in the frame.sml; but I separated it out 
                        to facilitate smooth collaborations.

 codegen.sml        --- implement your munchExp, munchStm, procEntryExit, 
                        etc. here. Again note in Appel's book, all 
                        procEntryExit functions are left in the frame.sml;
                        I again separated them out for smooth collaborations.

You should work on register.sml, codegen.sml, plus detailed documentations.
You are also primarily responsible for making sure that the final assembly 
code actually runs --- of course this requires that you coordinate closely
with people working on other two projects, asking them to fix bugs, etc.

=============================================================================
4. The RegAlloc Project
=============================================================================

The RegAlloc project is to implement the exercises described in 
the end of Chapter 10 and 11, in Appel's book.

The input you take is a list of assembly instructions described in assem.sml.
In the beginning, the CodeGen group will supply you some sample instructions 
for you to test upon. 

Your actual register allocation algorithm can be divided into three phases:

 (a) makegraph.sml --- from the list of assembly instructions, build 
                       the flowgraph  (described in Appel Chapter 10)

 (b) liveness.sml --- from the flowgraph, build the liveness interference
                      graph (described in Appel Chapter 10)

 (c) regalloc.sml --- do the register allocation (Appel Chapter 11)

You should return the list of assembly instructions, the live-tempoarary 
information, and a mapping from temporaries to actual machine registers.

The "as6/RegAlloc" directory contains the following files:

 graph.sig          --- the interface of the Graph datatype
 graph.sml          --- an implementation of the Graph datatype
 flowgraph.sml      --- the flowgraph definition and utility functions
 dotgraph.sml       --- printing out the Graph using the "dot" command.
                         (* "dot" is a graph-drawing tool; unfortunately
                            it is not supported on PowerPC; but if you 
                            insist in using such a tool, check out the
                            "/c/cs421/lib/Dot-INFO" file for more info *)

 makegraph.sml      --- a skeleton "makegraph.sml" described in Appel Page 113
 liveness.sml       --- a skeleton "liveness.sml" described in Appel Page 117
 regalloc.sml       --- a skeleton "regalloc.sml" described in Appel Page 140

You should work on makegraph.sml, liveness.sml, regalloc.sml plus detailed 
documentations. 


=============================================================================
5. What to Submit 
=============================================================================

This assignment takes 2.5 weeks, and is divided into the following 5 stages, 

*Assignment 6a FakeOutput (20 points, due 11/1/10)
   Write a dummy version of your modules that ignores its input
   and produces the output appropriate for a given sample program.

*Assignment 6b MostlyCorrect (20 points, due 11/5/10)
   Write a version of your module that mostly works.
   Verify that the dummy input given to you by other teams is reasonable
   and correct.

*Assignment 6c WarrantedCorrect (20 points, due 11/9/10)
   Produce a version of your module that you warrant as correct.

*Assignment 6d Documented&BugFixed (20 points, due 11/13/10)
   Prepare a beautifully documented version for your classmates
   to read. And, since warrantees aren't everything, fix the bugs 
   reported to you by your classmates.

*Assignment 6e CompleteCompiler (120 points, due 11/17/10)
   Make everything work and submit a Complete Compiler.  
   In your README, list which team implemented which module in your 
   working compiler.  But each team must individually hook all the 
   parts together.

For each stage, you always need to submit the following into the 
"/c/cs421/as/Public/6{a,b,c,d,e}/Your-Group-Code/" directory:

(1) README --- detailed documentations about 
        <i> what you have done so far
       <ii> how other groups would use your code (i.e., the bin files) ? 
      <iii> what assumptions you have made about your current implementations ?
       <iv> what desirable features you would like other groups to work on ?
        <v> if you have changed more files than required, explain it here.

(2) The following source files plus any files you changed ...
      ItreeGen: semant.sml, env.sml, translate.sml, frame.sml
       CodeGen: register.sml, codegen.sml
      RegAlloc: makegraph.sml, liveness.sml, regalloc.sml 

(3) The CM dependency and binary files for the above source files.
    If you use your submit directory as your working directory, the 
    dependency and the binary files will be automatically stored in the
    right place ---  in the 
        "/c/cs421/as/Public/6{a,b,c,d,e}/Your-Group-Code/CM" 
    directory. 

You can read-protect the *.sml files, but don't read-protect the CM
directory and the files inside since others might want to use your 
bin files.

=============================================================================
6. Other Tips
=============================================================================

o The "/c/cs421/as/as6" directory contains the CM dependency files 
  (in CM/DEPEND) and the CM bin files (in CM/x86-unix) for all the 
  current ML source files in as6. 

  If you want to use a file named foo.sml in the directory bar, just
  put "bar/foo.sml" in your sources.cm file. Notice that you may not
  be allowed to modify "foo.sml" and all the files that foo.sml 
  depends on.

o You may want to use the function ErrorMsg.impossible (in errormsg.sml,
  with type "string -> 'a") to print out any un-expected compiler errors, 
  for example,

       fun error s = ErrorMsg.impossible ("Foo:" ^ s)

       fun merge([],[]) = []
         | merge(f::r, s::z) =  .... 
         | merge _ = error "diff # of args in merge in translate.sml"

o You need to know more about the PowerPC assembly language and the PowerPC 
  machine architecture in order to work on your project (this is especially
  so if you are working on the CodeGen project). Here is how to find these 
  information about PowerPC:

        For PowerPC, the standard frame layout, the details of the
        assembly language can be found in the PowerPC on-line documentation 
        through InfoExplorer (type "info" at command line, and then look
        in the Topic & Index window --- follow the hypertext link 
               "Programming";  then "Languages"; then 
               "AIX version 4.1 Assembly Language Reference")

        The frame layout info is in 
               "Chapter 5. Assembling and Linking a Program"
        and Section "Subroutine Linkage Convention".

        "InfoExplorer" has to be run under the PPC desktop environment.
        Articles in "InfoExplorer" can also be printed out, click "Help"
        button in "InfoExplorer" to learn how to print a document.

  You can also use the "gcc -S test.c" to assemble a C program and to
  understand more about PowerPC assembly code.

=============================================================================
7. Standard Register Interface
=============================================================================

In order to let every one share each's bin files smoothly, We have set
up a standard register inferface file called "reg-std.sig". 

This file defines a signature called "REGISTER_STD"; its contents
are as follows:

-----------------------------------------------------------------------
(* this file is available as /c/cs421/as/as6/reg-std.sml *)

(* reg-std.sig *)

signature REGISTER_STD = 
sig
  type register = string

  val RV : Temp.temp  (* return value *)
  val FP : Temp.temp  (* frame pointer *)

  val SP   : Temp.temp
  val TOC  : Temp.temp
  val RA   : Temp.temp
  val ZERO : Temp.temp
  val ARG1 : Temp.temp
  val ARG2 : Temp.temp
  val ARG3 : Temp.temp
  val ARG4 : Temp.temp
  val ARG5 : Temp.temp
  val ARG6 : Temp.temp
  val ARG7 : Temp.temp
  val ARG8 : Temp.temp

  val paramBaseOffset : int
  val localsBaseOffset : int
  val specialregs : (Temp.temp * register) list
  val argregs : (Temp.temp * register) list
  val calleesaves : register list
  val callersaves : register list

end  (* signature REGISTER_STD *)

-----------------------------------------------------------------------
NOTE: Comments on register interface [by Chris League 10/28/1999]

This semester we are going to do our compiler project on the Intel
machines.  Generating code for Intel machines is trickier than for
RISC machines, mostly because there are so few general-purpose
registers.  

One common technique, is to use a fixed set of pseudo-registers
(not the unbounded temporaries) in addition to the non-dedicated
general-purpose registers.  The register allocator will map the
unbounded temporaries to pseudo- and physical registers.  The
pseudo-registers will be kept in memory (on the stack) and loaded
into dedicated registers when they are needed as operands of some
instruction.  Then, the result of that instruction is stored back to
the pseudo-register, if needed.

The pseudo-registers are just an abstraction we present to the
register allocator.  Eventually, we have to generate code to load
pseudo-registers into physical ones, and vice versa.

On RISC machines, we also try to pass function arguments in
registers.  For Intel, we give up on that completely and always use
the stack.  Functions do return values in a dedicated register,
though.

I've made some changes to the REGISTER and CODEGEN interfaces an
/c/cs421/as/as6/, specifically, I changed the files

    reg-std.sig
    CodeGen/register.sml 
    CodeGen/codegen.sml

In the REGISTER_STD signature, I deleted all the ARGn dedicated
temporaries, since we are not passing arguments in registers at
all.  We added paramBaseOffset (in addition to localsBaseOffset),
which gives the offset of parameters from the frame pointer.
Finally, I deleted the `argregs' function, which mapped the
temporaries reserved for argument passing to the dedicated physical
registers.

I believe this signature should work just fine for everyone, but if
you have concerns or think you need some information that isn't
there, please raise your question on the newsgroup ASAP.

The remaining changes mostly affect the CodeGen groups.

In `CodeGen/register.sml', I incorporated the changes to the
REGISTER_STD, and added temporaries for ECX and EDX, physical
registers that we will use to house values in pseudo-registers when
they need to be operated upon.  There is also a new list
`truecallersaves' which gives the non-virtual registers that need to
be saved before a call.  (It is never necessary to save these virtual
registers, since we allocate a new set in each new frame.)  Finally,
the function `regname' should produce an assembly language name for
any given register or pseudo-register.

In `CodeGen/codegen.sml', I added one function which will convert
all pseudo-register references in an instruction stream into valid
load/store sequences.  This function has been implemented for you.
This way, when doing normal code generation, you can just be
care-free about inserting pseudo-register references into your
instructions, and convert those to memory loads and stores in a
second pass.

I hope these changes will allow us to generate code for Intel and
still have a standardized, somewhat clean interface that still
matches the code from the book.  Thanks again to Antony; I borrowed
most of his work from last year's project, since I didn't feel
confident redesigning the interface myself.  If you run into any
problems, please email me or post ASAP, and we will try to get them
resolved.  

-----------------------------------------------------------------------
Q. How to conform your work to this standard interface ?

(1) To ItreeGen Groups:

    In env.sml, semant.sml and translate.sml, instead of directly 
    defining structures called Env, Semant and Translate, we now
    define functors (i.e., parameterized modules or parameterized
    structures) instead:

    The "translate.sml" looks like the following:

       (* in translate.sml *)
       functor TranslateGen(Register: REGISTER_STD) : TRANSLATE = 
         struct
               .... you can still refer to any thing in Register
                    by using Register.RV, or Register.FP, etc.
         end


    The "env.sml" looks like the following, the reason it is
    parameterized by Translate is because Env refers to the level
    datatype defined in Trnaslate.

        functor EnvGen(Translate: TRANSLATE) : ENV = 
          struct
            structure Tr = Translate

            type level = Tr.level

            (* same old stuff *)

          end (* functor EnvGen *)

     The "semant.sml" looks like the folowing 

        functor SemantGen(Register: REGISTER_STD) : SEMANT = 
          struct
           structure Translate = TranslateGen(Register)
           structure Env = EnvGen(Translate)

           (* other stuff *)

          end

    To use the structure of Semant, you have to first add a new line:

        structure Semant = SemantGen(Register)

    (see test.sml or the top-level glue file main.sml)

    The main purpose of converting structures into functors is to let your 
    env.sml, translate.sml, semant.sml not depends on register.sml directly. 
    (thus their bin files can be shared by all groups ...)
    Only your top-level glue will depend on CodeGen's register.sml.

    Since the tiger program is an expression, you are supposed to return its
    binary value (4-byte integer) to main().

(2) To RegAlloc Groups:
 
    The register allocation modules are now parameterized by the
    standard register interface also. 

    The signature REG_ALLOC now refers to REGISTER_STD

       signature REG_ALLOC =
       sig
         structure R : REGISTER_STD
   
         ...................
       end (* signature REG_ALLOC *)


    The RegAlloc structure is now changed into RegAllocGen, a parameterized
    module. Inside the module, you can refer to everything in Register
    as usual.

       functor RegAllocGen(Register : REGISTER_STD) : REG_ALLOC =
       struct
         structure R : REGISTER_STD = Register

         (* your usual stuff ... *)

       end 

    The only difference is that to use you register allocation functions:
    you must say

       structure RegAlloc = RegAllocGen(Register)

    in your top-level glue. The main purpose of converting structure into
    functor is to let your regalloc.sml no longer depends on register.sml
    directly. (thus their bin files can be shared by all groups ...)
    Only your top-level glue will depend on CodeGen's register.sml.


(3) To CodeGen Groups:

    Your REGISTER signature must contain those entries defined 
    in the standard register interface, even if some of these temporaries
    are not useful to you ! 

    Check out the  /c/cs421/as/as6/CodeGen/register.sml for examples.

    Once again, it is OK to add more entries into your Register module
    and your REGISTER signature; but you must make sure that your REGISTER
    signature contains all the entries in the reg-std.sig.


(4) Top-Level Glue (/c/cs421/as/as6/main.sml)

    In order to refer to modules such as Semant and RegAlloc, we must 
    do the following first:

         structure Semant = SemantGen(Register)
         structure RegAlloc = RegAllocGen(Register)

-----------------------------------------------------------------------
Q. What are localsBaseOffset and paramBaseOffset for ? 

Different CodeGen groups put the "local variable" area at the different 
offset (of FP) in the stack frame. Most ItreeGen groups, on the other 
hand, assume that the "local-variable" area start at offset 0. 

The localsBaseOffset value in the REGISTER_STD interface 
(see /c/cs421/as/as6/reg-std.sig): 

    val localsBaseOffset : int

refers to the distance from the start of the "local-variable" area
to the FP in the # of bytes. The CodeGen group is responsible to supply
a value in their "register.sml" file.

To ItreeGen groups: when you define allocInFrame in translate.sml, 
  please adjust the offset properly based on the "localsBaseOffset" value
  supplied from the Register interface. 

To CodeGen groups: please supply such "localsBaseOffset" value in your
  register.sml file, and make sure that it is consistent with your 
  procEntryExit sequence and frame layout. 

Similarly, the paramBaseOffset value in the REGISTER_STD interface
refers to the distance from the start of the "formal parameter" area
to the FP in the # of bytes. The CodeGen group is responsible to supply
a value in their "register.sml" file. 

=============================================================================
